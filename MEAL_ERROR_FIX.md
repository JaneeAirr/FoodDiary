# Исправление ошибки 500 при сохранении meal

## Проблема
При попытке сохранить meal возникала ошибка 500 (Internal Server Error).

## Причины и исправления

### 1. Обработка ошибок в notification_service
**Проблема**: Если при создании уведомлений возникала ошибка, она могла привести к падению всего запроса.

**Исправление**: Добавлена обработка исключений в `check_and_create_daily_notifications()`:
- Ошибки при проверке калорий теперь логируются, но не прерывают выполнение
- Ошибки при проверке белка теперь логируются, но не прерывают выполнение

### 2. Обработка ошибок в perform_create
**Проблема**: Ошибки в `check_and_create_daily_notifications` могли привести к падению создания meal.

**Исправление**: В `MealViewSet.perform_create()` добавлен try-except блок:
- Ошибки при создании уведомлений логируются, но не прерывают создание meal
- Ошибки при создании meal логируются с полным traceback для отладки

### 3. Улучшенная валидация
**Добавлено**:
- Валидация `quantity` (должно быть > 0)
- Валидация наличия `food_id` в данных
- Более детальные сообщения об ошибках

## Измененные файлы

1. `backend/api/views.py`:
   - Улучшена обработка ошибок в `perform_create()`

2. `backend/api/serializers.py`:
   - Добавлена валидация `quantity`
   - Добавлена валидация `food_id`

3. `backend/api/notification_service.py`:
   - Добавлена обработка исключений при проверке калорий
   - Добавлена обработка исключений при проверке белка
   - Исправлена логика проверки напоминаний

## Тестирование

Создание meal теперь должно работать корректно даже если:
- У пользователя нет NutritionGoal
- Возникают ошибки при создании уведомлений
- Данные частично невалидны (будут показаны понятные ошибки)

## Рекомендации

Если ошибка 500 все еще возникает:
1. Проверьте логи Django сервера для детальной информации об ошибке
2. Убедитесь, что отправляются правильные данные:
   - `food_id` - число (ID продукта)
   - `date` - строка в формате "YYYY-MM-DD"
   - `meal_type` - одна из: "breakfast", "lunch", "dinner", "snack"
   - `quantity` - число > 0
3. Проверьте, что пользователь аутентифицирован (JWT токен валиден)
